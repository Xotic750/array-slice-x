{"version":3,"sources":["../src/array-slice-x.js"],"names":[],"mappings":"AAAA,OAAO,QAAP,MAAqB,aAArB;AACA,OAAO,WAAP,MAAwB,cAAxB;AACA,OAAO,OAAP,MAAoB,YAApB;AACA,OAAO,cAAP,MAA2B,oBAA3B;AACA,OAAO,OAAP,MAAoB,WAApB;AACA,OAAO,QAAP,MAAqB,WAArB;AACA,OAAO,SAAP,MAAsB,oBAAtB;AAEA,IAAM,eAAe,GAAG,SAAS,CAAC,GAAG,KAAJ,CAAjC;;AAEA,IAAM,SAAS,GAAG,SAAS,SAAT,GAAqB;AACrC,MAAM,GAAG,GAAG,OAAO,CAAC,SAAS,SAAT,GAAqB;AACvC,WAAO,eAAe,CAAC,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAAD,EAAY,CAAZ,EAAe,CAAf,CAAtB;AACD,GAFkB,CAAnB;AAIA,SAAO,GAAG,CAAC,KAAJ,IAAa,OAAO,CAAC,GAAG,CAAC,KAAL,CAAP,KAAuB,KAApC,IAA6C,GAAG,CAAC,KAAJ,CAAU,MAAV,KAAqB,CAAlE,IAAuE,GAAG,CAAC,KAAJ,CAAU,CAAV,MAAiB,CAA/F;AACD,CAND;;AAQA,IAAM,UAAU,GAAG,SAAS,UAAT,GAAsB;AACvC,MAAM,GAAG,GAAG,OAAO,CAAC,SAAS,SAAT,GAAqB;AACvC,WAAO,eAAe,CAAC,KAAD,EAAQ,CAAR,EAAW,CAAX,CAAtB;AACD,GAFkB,CAAnB;AAIA,SAAO,GAAG,CAAC,KAAJ,IAAa,OAAO,CAAC,GAAG,CAAC,KAAL,CAAP,KAAuB,KAApC,IAA6C,GAAG,CAAC,KAAJ,CAAU,MAAV,KAAqB,CAAlE,IAAuE,GAAG,CAAC,KAAJ,CAAU,CAAV,MAAiB,GAA/F;AACD,CAND;;AAQA,IAAM,OAAO,GAAG,SAAS,OAAT,GAAmB;AACjC,MAAM,GAAG,GAAG,OAAO,QAAP,KAAoB,WAApB,IAAmC,QAA/C;AACA,MAAM,gBAAgB,GAAG,GAAG,GACxB,OAAO,CAAC,SAAS,SAAT,GAAqB;AAC3B,WAAO,eAAe,CAAC,GAAG,CAAC,eAAL,CAAtB;AACD,GAFM,CAAP,CAEG,KAHqB,GAIxB,KAJJ;AAMA,SAAO,gBAAgB,GAAG,gBAAgB,CAAC,KAApB,GAA4B,KAAnD;AACD,CATD;;AAWA,IAAM,SAAS,GAAG,SAAS,EAA3B;AACA,IAAM,UAAU,GAAG,UAAU,EAA7B;AACA,IAAM,OAAO,GAAG,OAAO,EAAvB;;AAEA,IAAM,YAAY,GAAG,SAAS,YAAT,CAAsB,MAAtB,EAA8B;AACjD,SAAO,SAAS,IAAK,OAAO,IAAI,OAAO,CAAC,MAAD,CAAP,KAAoB,KAA7C,IAAwD,UAAU,IAAI,QAAQ,CAAC,MAAD,CAA9E,IAA2F,WAAW,CAAC,MAAD,CAA7G;AACD,CAFD;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;AAuBA,IAAM,KAAK,GAAG,SAAS,KAAT,CAAe,KAAf,EAAsB,KAAtB,EAA6B,GAA7B,EAAkC;AAC9C,MAAM,MAAM,GAAG,QAAQ,CAAC,KAAD,CAAvB;AAEA,SAAO,YAAY,CAAC,MAAD,CAAZ,GAAuB,cAAc,CAAC,MAAD,EAAS,KAAT,EAAgB,GAAhB,CAArC,GAA4D,eAAe,CAAC,MAAD,EAAS,KAAT,EAAgB,GAAhB,CAAlF;AACD,CAJD;;AAMA,eAAe,KAAf","file":"array-slice-x.esm.js","sourcesContent":["import toObject from 'to-object-x';\nimport isArguments from 'is-arguments';\nimport isArray from 'is-array-x';\nimport arrayLikeSlice from 'array-like-slice-x';\nimport attempt from 'attempt-x';\nimport isString from 'is-string';\nimport methodize from 'simple-methodize-x';\n\nconst methodizedSlice = methodize([].slice);\n\nconst testArray = function testArray() {\n  const res = attempt(function attemptee() {\n    return methodizedSlice([1, 2, 3], 1, 2);\n  });\n\n  return res.threw || isArray(res.value) === false || res.value.length !== 1 || res.value[0] !== 2;\n};\n\nconst testString = function testString() {\n  const res = attempt(function attemptee() {\n    return methodizedSlice('abc', 1, 2);\n  });\n\n  return res.threw || isArray(res.value) === false || res.value.length !== 1 || res.value[0] !== 'b';\n};\n\nconst testDOM = function testDOM() {\n  const doc = typeof document !== 'undefined' && document;\n  const resultDocElement = doc\n    ? attempt(function attemptee() {\n        return methodizedSlice(doc.documentElement);\n      }).threw\n    : false;\n\n  return resultDocElement ? resultDocElement.threw : false;\n};\n\nconst failArray = testArray();\nconst failString = testString();\nconst failDOM = testDOM();\n\nconst useArrayLike = function useArrayLike(object) {\n  return failArray || (failDOM && isArray(object) === false) || (failString && isString(object)) || isArguments(object);\n};\n\n/**\n * The slice() method returns a shallow copy of a portion of an array into a new\n * array object selected from begin to end (end not included). The original\n * array will not be modified.\n *\n * @param {Array|object} array - The array to slice.\n * @param {number} [start] - Zero-based index at which to begin extraction.\n *  A negative index can be used, indicating an offset from the end of the\n *  sequence. Running slice(-2) extracts the last two elements in the sequence.\n *  If begin is undefined, slice begins from index 0.\n * @param {number} [end] - Zero-based index before which to end extraction.\n *  Slice extracts up to but not including end. For example, slice(1,4)\n *  extracts the second element through the fourth element (elements indexed\n *  1, 2, and 3).\n *  A negative index can be used, indicating an offset from the end of the\n *  sequence. Running slice(2,-1) extracts the third element through the second-to-last\n *  element in the sequence.\n *  If end is omitted, slice extracts through the end of the\n *  sequence (arr.length).\n *  If end is greater than the length of the sequence, slice extracts through\n *  the end of the sequence (arr.length).\n * @returns {Array} A new array containing the extracted elements.\n */\nconst slice = function slice(array, start, end) {\n  const object = toObject(array);\n\n  return useArrayLike(object) ? arrayLikeSlice(object, start, end) : methodizedSlice(object, start, end);\n};\n\nexport default slice;\n"]}